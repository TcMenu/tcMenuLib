//
// ESP32 S2 example based on Saola board with a dashboard configuration onto an OLED display
// I2C on standard pin, 8 and 9 with an SH1106 display
// encoder on 5, 6 with button on 7
// Getting started: https://tcmenu.github.io/documentation/arduino-libraries/tc-menu/tcmenu-overview-quick-start/
//

#include "esp32s2Saola_menu.h"
#include <PlatformDetermination.h>

#include <TaskManagerIO.h>
#include <EEPROM.h>
#include <tcMenuVersion.h>
#include <WiFi.h>
#include <stockIcons/wifiAndConnectionIcons16x12.h>
#include <tcUtil.h>
#include <SPI.h>
#include <BaseDialog.h>

#include "graphics/TcThemeBuilder.h"

#define MENU_WIFIMODE_STATION 0
bool  connectedToWiFi = false;
void startWiFiAndListener();

// we add two widgets, one generated by tcMenu Designer Bitmap and Widget Creator, and the inbuilt Wi-Fi widget
// START widgets

// https://tcmenu.github.io/documentation/arduino-libraries//tc-menu/rendering-with-tcmenu-lcd-tft-oled
TitleWidget wifiWidget(iconsWifi, 5, 16, 12);

using namespace tcgfx;

// XBM_LSB_FIRST width=12, height=12, size=24
// auto size = Coord(12, 12);
const uint8_t myWidgetWidIcon0[] PROGMEM = {
    0x00,0x00,0x8e,0x03,0x51,0x04,0x51,0x04,0x51,0x04,0x51,0x04,0x51,0x04,0x51,0x04,0x59,0x06,0x5d,0x07,
    0x5d,0x07,0x8e,0x03
    };
// XBM_LSB_FIRST width=12, height=12, size=24
// auto size = Coord(12, 12);
const uint8_t myWidgetWidIcon1[] PROGMEM = {
    0x00,0x00,0x8e,0x03,0xd7,0x05,0xd7,0x05,0xd3,0x04,0x51,0x04,0x51,0x04,0x51,0x04,0x51,0x04,0x51,0x04,
    0x51,0x04,0x8e,0x03
    };
const uint8_t* const myWidgetWidIcons[] PROGMEM = { myWidgetWidIcon0, myWidgetWidIcon1 };

// See https://tcmenu.github.io/documentation/arduino-libraries//tc-menu/creating-and-using-bitmaps-menu/
TitleWidget myWidgetWidget(myWidgetWidIcons, 2, 12, 12, nullptr);

// END widgets

void setup() {
    // before proceeding, we must start wire and serial, then call setup menu.
    Serial.begin(115200);
    serdebugF("Starting ESP32-S2 example");
    SPI.begin(36, 37, 35, -1);

    setupMenu();

    // always call load after setupMenu, as the EEPROM you chose in initialised only after this setupMenu()
    menuMgr.load();

    // set the number of rows in the list.
    getListItemById(EXTRAS_LIST_ID).setNumberOfRows(42);

    // next start WiFi and register our wifi widget
    startWiFiAndListener();

    auto themeBuilder = TcThemeBuilder(renderer);
    themeBuilder.addingTitleWidget(wifiWidget);
    themeBuilder.addingTitleWidget(myWidgetWidget);

    // lastly we capture when the root title is pressed present a standard version dialog.
    setTitlePressedCallback([](int titleCb) {
        showVersionDialog(&applicationInfo);
    });
}

void loop() {
    taskManager.runLoop();
}

void startWiFiAndListener() {
    TextMenuItem& ssidMenuItem = getTextItemById(CONNECTIVITY_SSID_ID);
    TextMenuItem& passphraseMenuItem = getTextItemById(CONNECTIVITY_PASSCODE_ID);
    // You can choose between station and access point mode by setting the connectivity/Wifi Mode option to your
    // own choice
    if(asEnumItem(getMenuItemById(CONNECTIVITY_WIFI_MODE_ID)).getCurrentValue() == MENU_WIFIMODE_STATION) {
        // we are in station mode
        WiFi.begin(ssidMenuItem.getTextValue(), passphraseMenuItem.getTextValue());
        WiFi.mode(WIFI_STA);
        serdebugF("Connecting to Wifi using settings from connectivity menu");
    }
    else {
        // we are in access point mode
        WiFi.mode(WIFI_AP);
        char ssid[25];
        char pwd[25];
        copyMenuItemValueDefault(&ssidMenuItem, ssid, sizeof ssid, "tcmenu");
        copyMenuItemValueDefault(&passphraseMenuItem, pwd, sizeof pwd, "secret");
        WiFi.softAP(ssid, pwd);
        serdebugF3("Started up in AP mode, connect with ", ssid, pwd);
    }

    //
    // Here we use the inbuilt task manager to schedule something to run every second. To use
    // it you simply provide either a function callback or a lambda as we do here.
    //
    taskManager.schedule(repeatSeconds(1), [] {
        // check the wifi connection status
        if(WiFi.status() == WL_CONNECTED) {
            if(!connectedToWiFi) {
                // we are fully connected, so we now get the address that DHCP gave us to put into
                // the Ip Address item.
                IPAddress localIp = WiFi.localIP();
                Serial.print("Now connected to WiFi");
                Serial.println(localIp);
                getIpAddressItemById(CONNECTIVITY_IP_ADDR_ID).setIpAddress(localIp[0], localIp[1], localIp[2], localIp[3]);
                connectedToWiFi = true;
            }

            // if the networking is up, then we always render the current signal strength in the title widget.
            wifiWidget.setCurrentState(fromWiFiRSSITo4StateIndicator(WiFi.RSSI()));
        }
        else {
            // We've not got networking, set it
            connectedToWiFi = false;
            wifiWidget.setCurrentState(0);
        }
    });
}

void CALLBACK_FUNCTION pressMeActionRun(int id) {
    menuMgr.save();
    EEPROM.commit();
    auto dlg = renderer.getDialog();
    if(!dlg->isInUse()) {
        dlg->setButtons(BTNTYPE_NONE, BTNTYPE_CLOSE);
        dlg->showRam("Saved", false);
        dlg->copyIntoBuffer("to flash");
    }
}


// This callback needs to be implemented by you, see the below docs:
//  1. List Docs - https://tcmenu.github.io/documentation/arduino-libraries/tc-menu/menu-item-types/list-menu-item/
//  2. ScrollChoice Docs - https://tcmenu.github.io/documentation/arduino-libraries//tc-menu/menu-item-types/scrollchoice-menu-item/
int CALLBACK_FUNCTION fnExtrasMyListRtCall(RuntimeMenuItem* item, uint8_t row, RenderFnMode mode, char* buffer, int bufferSize) {
    if(mode == RENDERFN_VALUE && row != LIST_PARENT_ITEM_POS) {
        strncpy(buffer, "Val", bufferSize);
        fastltoa(buffer, row, 3, NOT_PADDED, bufferSize);
        return true;
    }
    return defaultRtListCallback(item, row, mode, buffer, bufferSize);
}

void CALLBACK_FUNCTION onListSelected(int id) {
    Serial.print("List item select "); Serial.println(getListItemById(EXTRAS_LIST_ID).getActiveIndex());
}


void CALLBACK_FUNCTION onHibernate(int id) {
    display.clearScreen();
    display.hibernate();
}
