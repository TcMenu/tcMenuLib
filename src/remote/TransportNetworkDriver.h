/*
    The code in this file uses open source libraries provided by thecoderscorner

    DO NOT EDIT THIS FILE, IT WILL BE GENERATED EVERY TIME YOU USE THE UI DESIGNER
    INSTEAD EITHER PUT CODE IN YOUR SKETCH OR CREATE ANOTHER SOURCE FILE.

    All the variables you may need access to are marked extern in this file for easy
    use elsewhere.
 */


#ifndef TCMENU_LWIP_DRIVER_H
#define TCMENU_LWIP_DRIVER_H

#include <PlatformDetermination.h>

/**
 * @file TransportNetworkDriver.h
 *
 * This file contains the API mappings that all network drivers must follow, this is the minimum API that allows
 * init, accept, read and write operations on a wide range of hardware. The functions are be implemented differently
 * for each type of OS or hardware. It is assumed that if any maintenance function needs to be called frequently that
 * the startNetLayer* function will ensure it is scheduled via task manager.
 *
 * All these methods should only be called on the *primary task manager*, and in most cases they will not block any
 * other tasks from running, even if blocking is required. No assumption about the type of socket_t should be made.
 */

#define TC_BAD_SOCKET_ID (-1)
#define TC_LOCALHOST_SOCKET_ID (-2)

namespace tcremote {

    /**
     * We define socket_t so that there is a standard way of referring to all socket connections, you should not
     * rely on anything other that comparing against TC_BAD_SOCKET_ID and  TC_LOCALHOST_SOCKET_ID
     */
    typedef int socket_t;
    enum SocketErrCode {
        /** This driver doesn't support reading from PROGMEM */
        SOCK_ERR_NO_PROGMEM_SUPPORT = -4,
        /** The operation timed out */
        SOCK_ERR_TIMEOUT = -3,
        /** The operation was not supported */
        SOCK_ERR_UNSUPPORTED = -2,
        /** A general failure occurred during processing */
        SOCK_ERR_FAILED = -1,
        /** The socket was closed */
        SOCK_ERR_CLOSED = 0,
        /** Operation was successful */
        SOCK_ERR_OK = 1
    };

    /**
     * Indicates where the memory for a given buffer resides, so write knows how to process it. This allows write to
     * make optimisations when possible. Note that program memory is not supported by all stacks and may return
     * SOCK_ERR_NO_PROGMEM_SUPPORT in some cases.
     */
    enum MemoryLocationType {
        /** the buffer is stored in program memory, as must be read from there as needed */
        IN_PROGRAM_MEM,
        /** the buffer is in constant memory and doesn't therefore need to be copied */
        CONSTANT_NO_COPY,
        /** the buffer is in transient RAM memory and therefore must be copied */
        RAM_NEEDS_COPY
    };

    /**
     * This is the callback used to indicate a new connection has been established and requires processing.
     * The call provides the socket reference as the first parameter and the second parameter is the callbackData
     * that you provided when registering the callback with accept.
     */
    typedef void (*ServerAcceptedCallback)(socket_t clientSocketFd, void* callbackData);

    /**
     * Start the networking layer using DHCP, this will also start a maintenance task with the primary task manager
     * if it is needed to manage connectivity. Note that this call will block the calling task if required but allow
     * other tasks to run while waiting.
     * @return an error code to indicate call status
     */
    SocketErrCode startNetLayerDhcp();

    /**
     * Start the network layer by manually providing the parameters, this will also start a maintenance task with the
     * primary task manager if it is needed to manage connectivity. Note that this call will block the calling task
     * if required but allow other tasks to run while waiting.
     * @param ip the ip address as four 8 bit digits
     * @param mac the mac address as six 8 bit digits
     * @param mask this is the netmask, mainly set to 255.255.255.0
     */
    SocketErrCode startNetLayerManual(const uint8_t* ip, const uint8_t* mac, const uint8_t* mask);

    /**
     * Copy the current address for a socket into the provided buffer, providing TC_LOCALHOST_SOCKET_ID get the host
     * address of this device.
     * @param buffer the buffer to copy into
     * @param bufferSize the size of the buffer
     */
    void copyIpAddress(socket_t theSocket, char* buffer, size_t bufferSize);

    /**
     * Check if the network is presently up
     * @return true if connected, otherwise false
     */
    bool isNetworkUp();

    /**
     * Initialise a server side accept on a given port, it will call back onServerAccepted when a connection is made.
     * @param port the port on which to accept
     * @return an error code to indicate call status
     */
    SocketErrCode initialiseAccept(int port, ServerAcceptedCallback onServerAccepted, void* callbackData);

    /**
     * Attempt to read data from the socket, returns 0 if nothing is available at present, -1 on connection closure.
     * @param socketNum the socket to read from
     * @param data the buffer to read into
     * @param dataLen the length of above buffer.
     * @return either the number of bytes read (could be 0), or -1 for an error.
     */
    int rawReadData(socket_t socketNum, void* data, size_t dataLen);

    /**
     * Determine if it is possible to do a raw read on this connecetion, return true if possible otherwise false
     * @return if it is possible to do a read now.
     */
    bool rawReadAvailable(socket_t sockFd);

    /**
     * Determine if we can write now without blocking on this connection
     * @param sockFd the socket to check
     * @return true if write wont block, otherwise false.
     */
    bool rawWriteAvailable(socket_t sockFd);

    /**
     * Write the amount of data specified by dataLen to the socket, this will block safely through the first task
     * manager if needed using it's yield function. It may or may not flush data to the socket.
     * @param socketNum the socket to write to
     * @param data the buffer to write
     * @param dataLen the amount to write from the buffer
     * @param locationType what type of memory the data is stored in (eg, constant, program, RAM).
     * @param timeoutMillis how long in milliseconds to wait for write to become available
     * @return an error code to indicate call status
     */
    SocketErrCode rawWriteData(socket_t socketNum, const void* data, size_t dataLen, MemoryLocationType locationType, int timeoutMillis = 30000);

    /**
     * Flush any data that has been cached for the socket provided.
     * @param socketNum the socket to flush
     * @return an error code to indicate call status
     */
    SocketErrCode rawFlushAll(socket_t socketNum);

    /**
     * closes the current socket
     * @param sockFd the socket to close
     */
    void closeSocket(socket_t sockFd);
}

#endif
